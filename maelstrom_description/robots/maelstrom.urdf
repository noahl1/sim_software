<?xml version="1.0" ?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by xacro from default.xacro                  | -->
<!-- |    EDITING THIS FILE BY HAND IS NOT RECOMMENDED                                 | -->
<!-- =================================================================================== -->
<robot name="maelstrom" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <!-- Some pretty colors -->
  <material name="blue">
    <color rgba="0.0 0.0 0.8 1.0"/>
  </material>
  <material name="green">
    <color rgba="0.0 0.8 0.0 1.0"/>
  </material>
  <material name="grey">
    <color rgba="0.7 0.7 0.7 1.0"/>
  </material>
  <material name="grey2">
    <color rgba="0.9 0.9 0.9 1.0"/>
  </material>
  <material name="red">
    <color rgba="0.8 0.0 0.0 1.0"/>
  </material>
  <material name="orange">
    <color rgba="1.0 0.5 0.0 1.0"/>
  </material>
  <material name="white">
    <color rgba="1.0 1.0 1.0 1.0"/>
  </material>
  <material name="black">
    <color rgba="0.05 0.05 0.05 1.0"/>
  </material>
  <!-- ROTOR DYNAMICS MACROS -->
  <!-- First order dynamics -->
  <!--
    MACROS FOR CONVERSION FUNCTIONS BETWEEN ROTOR'S ANG. VELOCITY AND
    THRUSTER FORCE
  -->
  <!-- THRUSTER MODULE MACROS  -->
  <!--
    Thruster model with first order dynamic model for the rotor dynamics
    and a proportional non-linear steady-state conversion from the rotor's
    angular velocity to output thrust force
  -->
  <!-- Rigid body description of the base link -->
  <link name="maelstrom/base_link">
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/maelstrom.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <collision>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/collision.stl" scale="1 1 1"/>
      </geometry>
    </collision>
  </link>
  <link name="maelstrom/inert">
    <inertial>
      <mass value="36.1"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.69" ixy="0" ixz="0" iyy="2.62" iyz="0" izz="2.51"/>
    </inertial>
  </link>
  <joint name="inert_base" type="fixed">
    <parent link="maelstrom/base_link"/>
    <child link="maelstrom/inert"/>
  </joint>
  <gazebo reference="maelstrom/base_link">
    <selfCollide>false</selfCollide>
  </gazebo>
  <gazebo reference="maelstrom/base_link">
    <visual>
      <material>
        <script>
          <name>maelstrom/supreme</name>
          <uri>/home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/maelstrom/scripts/supreme.material</uri>
        </script>
      </material>
    </visual>
  </gazebo>
  <!-- Set up hydrodynamic plugin given as input parameter -->
  <gazebo>
    <plugin filename="libuuv_underwater_object_ros_plugin.so" name="uuv_plugin">
      <fluid_density>1028.0</fluid_density>
      <flow_velocity_topic>hydrodynamics/current_velocity</flow_velocity_topic>
      <debug>0</debug>
      <!-- List of hydrodynamic models this robot's links -->
      <link name="maelstrom/base_link">
        <!-- This flag will make the link neutrally buoyant -->
        <neutrally_buoyant>0</neutrally_buoyant>
        <!-- Link's volume -->
        <volume>0.0386</volume>
        <!-- Link's bounding box, it is used to recalculate the immersed
        volume when close to the surface.
        This is a workaround the invalid bounding box given by Gazebo-->
        <box>
          <width>0.346</width>
          <length>0.782</length>
          <height>0.967</height>
        </box>
        <!-- Center of buoyancy -->
        <center_of_buoyancy>0 0 0</center_of_buoyancy>
        <!-- All these values stolen from RexROV2... need to compute
        for Maelstrom -->
        <hydrodynamic_model>
          <type>fossen</type>
          <added_mass>
        1.7 0 0 0 0 0
        0 0 0 0 0 0
        0 0 5 0 0 0
        0 0 0 0 0 0
        0 0 0 1.5 0 0
        0 0 0 0 0 .4
        </added_mass>
          <linear_damping>
        -11.7391 -20 -31.8678 -25 -44.9085 -5
        </linear_damping>
        </hydrodynamic_model>
      </link>
      <!--
          In case other modules are added to the vehicle (such as a manipulator)
          that also have link running with the underwater object plugin, they
          should also be added in this block. For this, this new module should
          have a file similar to gazebo.xacro above with the description of the
          parameter necessary for the underwater object plugin to be initialized.
        -->
    </plugin>
  </gazebo>
  <!-- Adding the thruster units with the macro created in snippets.xacro -->
  <!--
    Important:
        - The thruster IDs must be given as integers and must be unique to each thruster unit
        - The thruster pose in the <origin> block is relative to the body's center of mass. Be
          aware that Gazebo does not use the SNAME convention per default.
    -->
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_HSA">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_HSA_joint" type="continuous">
    <origin rpy="0 1.57079632679 0" xyz="-0.32577 -0.18946 -0.01509"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_HSA"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_HSA_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_HSA</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_HSA_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>HSA</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_HSA">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_HPA">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_HPA_joint" type="continuous">
    <origin rpy="0 1.57079632679 0" xyz="-0.32577 0.18946 -0.01509"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_HPA"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_HPA_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_HPA</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_HPA_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>HPA</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_HPA">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_HPF">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_HPF_joint" type="continuous">
    <origin rpy="0 1.57079632679 0" xyz="0.37273 0.18946 -0.01509"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_HPF"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_HPF_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_HPF</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_HPF_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>HPF</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_HPF">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_HSF">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_HSF_joint" type="continuous">
    <origin rpy="0 1.57079632679 0" xyz="0.37273 -0.18946 -0.01509"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_HSF"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_HSF_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_HSF</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_HSF_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>HSF</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_HSF">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_VPF">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_VPF_joint" type="continuous">
    <origin rpy="0 0 -0.785398163397" xyz="0.41921 0.30628 0.10615"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_VPF"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_VPF_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_VPF</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_VPF_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>VPF</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_VPF">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_VPA">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_VPA_joint" type="continuous">
    <origin rpy="0 0 0.785398163397" xyz="-0.37225 0.30628 0.10615"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_VPA"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_VPA_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_VPA</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_VPA_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>VPA</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_VPA">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_VSF">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_VSF_joint" type="continuous">
    <origin rpy="0 0 0.785398163397" xyz="0.41921 -0.30628 0.10615"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_VSF"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_VSF_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_VSF</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_VSF_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>VSF</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_VSF">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="maelstrom/thruster_VSA">
    <visual>
      <geometry>
        <mesh filename="file:///home/noah/osu-uwrt/sim_software/src/maelstrom_description/meshes/prop.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="maelstrom/thruster_VSA_joint" type="continuous">
    <origin rpy="0 0 -0.785398163397" xyz="-0.37225 -0.30628 0.10615"/>
    <axis xyz="1 0 0"/>
    <parent link="maelstrom/inert"/>
    <child link="maelstrom/thruster_VSA"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="maelstrom_VSA_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>maelstrom/thruster_VSA</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>maelstrom/thruster_VSA_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>VSA</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Maximum allowed input value for the input signal for thruster unit -->
      <clampMax>24</clampMax>
      <!-- Minimum allowed value for the input signal for thruster unit -->
      <clampMin>-24</clampMin>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-24</thrustMin>
      <thrustMax>24</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <!-- TODO: Find good thruster model -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>0.005</rotorConstant>
      </conversion>
    </plugin>
  </gazebo>
  <gazebo reference="maelstrom/thruster_VSA">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Some examples of sensors that can be added to the vehicle frame.
    Set the origin of the sensor frames correctly for your application
    Look into the sensor macros in the package uuv_sensor_ros_plugins/urdf for
    more examples or add you own custom sensor units.
  -->
  <gazebo>
    <plugin filename="libuuv_joint_state_publisher.so" name="joint_state_publisher">
      <robotNamespace>maelstrom</robotNamespace>
      <updateRate>10</updateRate>
    </plugin>
  </gazebo>
</robot>

